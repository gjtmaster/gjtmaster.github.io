<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="心有多大，舞台就有多大！"><title>Flink底层原理：流处理基本概念 | Joker's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Flink底层原理：流处理基本概念</h1><a id="logo" href="/.">Joker's Blog</a><p class="description">高金涛</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Flink底层原理：流处理基本概念</h1><div class="post-meta">May 3, 2018<span> | </span><span class="category"><a href="/categories/实时计算框架/">实时计算框架</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dataflow-Programming"><span class="toc-number">1.</span> <span class="toc-text">Dataflow Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据流图"><span class="toc-number">1.1.</span> <span class="toc-text">数据流图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据并行与任务并行"><span class="toc-number">1.2.</span> <span class="toc-text">数据并行与任务并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据交换策略"><span class="toc-number">1.3.</span> <span class="toc-text">数据交换策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行流处理"><span class="toc-number">2.</span> <span class="toc-text">并行流处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟与吞吐"><span class="toc-number">2.1.</span> <span class="toc-text">延迟与吞吐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟"><span class="toc-number">2.2.</span> <span class="toc-text">延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#吞吐"><span class="toc-number">2.3.</span> <span class="toc-text">吞吐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟-vs-吞吐"><span class="toc-number">2.4.</span> <span class="toc-text">延迟 vs 吞吐</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="Dataflow-Programming"><a href="#Dataflow-Programming" class="headerlink" title="Dataflow Programming"></a>Dataflow Programming</h2><p>在讨论流处理的基本概念之前，我们首先介绍一下数据流编程（dataflow programming）的基本概念与术语。</p>
<h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><p>数据流程序一般由数据流图表示，数据流图描述了数据如何在操作之间流动。在数据流图中，节点被称为operator，代表计算；边代表数据依赖。</p>
<p>Operator是dataflow 应用中的基本单元，它们从输入消费数据，在之上执行计算，并生产数据提供给下一步处理。</p>
<p>没有输入的operators 称为数据源（data sources），没有输出的operator称为数据接收器（data sink）。一个dataflow graph 必须有至少一个data source以及一个data sink。例如：</p>
<p><img src="https://img2018.cnblogs.com/blog/1287132/201905/1287132-20190510091510356-305611451.png" alt="img"></p>
<p>类似上图的dataflow graph 称为逻辑的（logical）数据流图，因为它们从高层的视角展示了计算逻辑。在执行时，逻辑图会被转换为物理图（physical dataflow graph），具体的执行逻辑会在物理数据流图中给出，如下图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1287132/201905/1287132-20190510091535522-555450626.png" alt="img"></p>
<p>例如，如果我们使用分布式处理引擎，每个operator可能有多个并行的任务跑在不同的物理机器上。逻辑图表示了执行的逻辑，而物理图表示了具体的任务。</p>
<h3 id="数据并行与任务并行"><a href="#数据并行与任务并行" class="headerlink" title="数据并行与任务并行"></a>数据并行与任务并行</h3><p>数据并行是指：将输入数据做partition，然后使用多个同样的task并行处理数据的子集。数据并行的意义在于将数据分散到多个计算节点上。</p>
<p>任务并行是指：有多个不同的task任务并行处理相同的或不同的数据。任务并行的意义在于更好的使用集群中的计算资源。</p>
<h3 id="数据交换策略"><a href="#数据交换策略" class="headerlink" title="数据交换策略"></a>数据交换策略</h3><p>数据交换策略定义了：在physical dataflow graph中，数据条目如何分发到task 中。下面是几种常见的数据交换策略：</p>
<ol>
<li>前向（forward）策略：从一个task发送数据到另一个接受task。如果两个task均在一个机器上，则可以避免网络传输</li>
<li>广播（broadcast）策略：数据发送到所有并行task中。此策略涉及到数据复制及网络传输，所以较为消耗资源</li>
<li>key-based 策略：根据key做partition，使具有相同key 的条目可以被同一个task处理</li>
<li>随机（random）策略：随机均匀分布数据到task中，均衡集群计算负载</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1287132/201905/1287132-20190510091552451-1460818339.png" alt="img"></p>
<h2 id="并行流处理"><a href="#并行流处理" class="headerlink" title="并行流处理"></a>并行流处理</h2><p>在了解以上概念后，我们接下来讨论并行流处理。首先，我们定义数据流（data stream）：数据流是一个（可能）无限的事件序列。</p>
<h3 id="延迟与吞吐"><a href="#延迟与吞吐" class="headerlink" title="延迟与吞吐"></a>延迟与吞吐</h3><p>对于批处理应用，我们一般关注的是一个job的整个执行时间，或是处理引擎需要多长时间读数据、计算、以及写入结果。而流处理应用是持续运行的，并且输入数据可能是无限的，所以对于整个应用的执行时间其实并没有太多关注。但是，流处理程序在处理高频率的事件输入的同时，还必须要在输入数据后尽可能快的提供结果。我们使用延迟（latency）与吞吐（throughput）来衡量这个需求。</p>
<h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><p>延迟表示的是处理一个event所需要的时间。本质上，它是从：接受到event -&gt; 到处理完此event -&gt; 并在结果中有体现，这段时间。举个例子，假设你去咖啡店买咖啡，前面有人排队，在到你点完单后，店里会做咖啡，做好后叫号，然后你来取，取完后开始喝。这里的latency指的就是从你进咖啡店开始，一直到你喝到第一口咖啡的间隔时间。</p>
<p>在data streaming 中，latency由时间衡量，例如毫秒。根据application的不同，你可能会关注平均延迟、最高延迟、或是百分位数延迟（percentile latency）。例如：平均延迟为10ms，表示events平均在10ms内被处理。而百分位 95 的延迟为10ms表示的是有95% 的events在10ms内被处理。平均延迟值隐藏了处理延迟的分布，可能会难以定位问题。例如：如果咖啡师在为你准备咖啡时用光了牛奶，则你不得不去等待咖啡师去拿牛奶，这里你的咖啡会有更大的延迟，但是其他大部分用户并不会受到影响。</p>
<p>对于大部分流应用来说（例如系统告警、欺诈检测、网络监控等），保证低延迟至关重要。低延迟在流处理中是一个重要的特性，它是实现“实时”应用的基础。当前主流的流处理器（如Flink），可以提供低至几毫秒的延迟。相对而言，传统的批处理系统的延迟可一般会达到几分钟到几小时不等。在批处理中，首先需要的是将events收集为batch，然后再处理它。所以它的延迟取决于batch中最后一个event到达的时间，以及batch 的大小。真正的流处理并不引入这种延迟，所以可以实现真正的低延迟。在真正的流模型中，events在到达流系统后可以被立即处理，此时的延迟反应的是：在此event上执行的操作时间。</p>
<h3 id="吞吐"><a href="#吞吐" class="headerlink" title="吞吐"></a>吞吐</h3><p>吞吐用于衡量系统的处理能力：处理率。也就是说，它可以告诉我们，系统在每个时间片内可以处理多少个events。以咖啡店为例，如果咖啡店从早上7点开到晚上7点，每天服务600个客户，则它的平均吞吐为 50个顾客/每小时。在流系统中，我们需要延迟尽可能的低，而吞吐尽可能的高。</p>
<p>吞吐由每个时间单位内处理的evnets衡量。这里需要注意的是：处理速率取决于events的到达速率。低吞吐并不能完全说明系统性能低。在流系统中，一般希望确保系统最高能处理events的速率。也就是说，我们主要关心的是确定吞吐的峰值（peak throughput）：在系统处于最高负载时的性能极限。为了更好地理解顶峰吞吐（peak throughput），我们考虑一个流处理应用，它一开始并不接收任何输入，所以此时并不消耗任何系统资源。当第一个event到来时，它会立即（尽量）以最小的latency 处理。例如你是咖啡馆开门的第一个顾客，店员会立即为你去做咖啡。在理想情况下，你会希望随着更多events的进入，latency 可以保持较小值不发生太大的变动。然而，一旦输入的events到达某个速率，使得系统资源被完全使用时，就不得不开始缓存（buffering）events。拿咖啡店举例，在中午的时候，人流量会特别大，达到了咖啡店的顶峰，则这时候就需要开始排队了。这时候系统即达到了它的peak throughput，而更大的event rate只会使得latency变得更糟。如果系统继续以更高的速率接收输入（超过了它可以处理的速率），缓冲区可能会爆掉，并导致数据丢失。常规的解决方案是背压（backpressure），并有不同的策略去处理。</p>
<h3 id="延迟-vs-吞吐"><a href="#延迟-vs-吞吐" class="headerlink" title="延迟 vs 吞吐"></a>延迟 vs 吞吐</h3><p>在这里需要明确的是，延迟与吞吐并不是两个互相独立的指标。如果事件到达数据处理管道的事件较长，便无法保证高吞吐。类似的，如果系统的性能较低，则events 会被缓存并等待，直到系统有能力处理。</p>
<p>再次以咖啡店为例，首先比较好理解的是，在负载低的时候，可以达到很好的一个latency。例如咖啡店里你是第一个也是唯一的一个顾客。但是在咖啡店较忙的时候，顾客就需要排队等待，此时的latency即会增加。另外一个影响延迟的因素（并继而影响到吞吐）是处理一个事件的时间。例如咖啡店为每个顾客做咖啡所消耗的时间。假设在一个圣诞节，咖啡师需要在每杯咖啡上画一个圣诞老人。也就是说，每杯咖啡制作的时间会增加，导致每个顾客在咖啡店消耗更多的时间，最终使得整体吞吐下降。</p>
<p>那是否可以同时达到低延迟与高吞吐？在咖啡店的例子中，你可以招聘更有经验的咖啡师，让做咖啡的效率更高。这里主要考量的地方是：减少延迟以增加吞吐。如果一个系统执行的操作更快，则它就可以在同一时间内处理更多的event。另外的方法是招聘更多的咖啡师，让同一时间有更多的客户被服务到。在流处理管道中，通过使用多个stream并行处理events，在获取更低的延时的同时，也可以在同一时间内处理更多的events。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>gaojintao999@163.com</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/05/03/Flink 底层原理：流处理基本概念/">https://gjtmaster.github.io/2018/05/03/Flink 底层原理：流处理基本概念/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>The author owns the copyright, please indicate the source reproduced.</li></ul></div><br><div class="tags"><a href="/tags/Flink/">Flink</a><a href="/tags/实时计算/">实时计算</a></div><div class="post-nav"><a class="pre" href="/2018/05/05/Flink 底层原理：如何处理反压问题/">Flink 底层原理：如何处理反压问题</a><a class="next" href="/2017/12/10/CentOS 7 命令行静默安装部署oracle11g数据库/">CentOS 7 命令行静默安装部署oracle11g数据库</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实时计算框架/">实时计算框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储格式/">数据存储格式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据的导入导出/">数据的导入导出</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志框架/">日志框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息中间件/">消息中间件</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Flink/" style="font-size: 15px;">Flink</a> <a href="/tags/实时计算/" style="font-size: 15px;">实时计算</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/Flink-on-Yarn/" style="font-size: 15px;">Flink on Yarn</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/消息中间件/" style="font-size: 15px;">消息中间件</a> <a href="/tags/Logback/" style="font-size: 15px;">Logback</a> <a href="/tags/Json/" style="font-size: 15px;">Json</a> <a href="/tags/FlinkSQL/" style="font-size: 15px;">FlinkSQL</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/内存回收/" style="font-size: 15px;">内存回收</a> <a href="/tags/ogg/" style="font-size: 15px;">ogg</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/Flink 进阶：Time 深度解析/">Flink 进阶：Time 深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/Flink 进阶：Flink Connector详解/">Flink 进阶：Flink Connector详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/16/Flink 进阶：增量 Checkpoint 详解/">Flink 进阶：增量 Checkpoint 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/15/Flink 进阶：Runtime 核心机制剖析/">Flink 进阶：Runtime 核心机制剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/FlinkSQL深度解析/">Flink SQL 深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/16/Flink on Yarn HA/">Flink On Yarn HA</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink使用Logback作为日志框架的相关配置/">Flink使用Logback作为日志框架的相关配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink On Yan集群部署/">Flink On Yarn集群部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink1.7.1与Kafka0.11.0.1/">Flink1.7.1与Kafka0.11.0.1</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/消息中间件高级技术要点企业级架构深入分析/">消息中间件高级技术要点企业级架构深入分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://matt33.com/" title="Matt's Blog" target="_blank">Matt's Blog</a><ul></ul><a href="https://www.haomwei.com/technology/maupassant-hexo.html" title="Maupassant's usage" target="_blank">Maupassant's usage</a><ul></ul><a href="https://www.jianshu.com/p/f4332764e8bd" title="hexo's usage" target="_blank">hexo's usage</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Joker's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>