<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="心有多大，舞台就有多大！"><title>kafka之Producer同步与异步消息发送及事务幂等性案例 | Joker's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kafka之Producer同步与异步消息发送及事务幂等性案例</h1><a id="logo" href="/.">Joker's Blog</a><p class="description">高金涛</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kafka之Producer同步与异步消息发送及事务幂等性案例</h1><div class="post-meta">Sep 15, 2018<span> | </span><span class="category"><a href="/categories/消息中间件/">消息中间件</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全"><span class="toc-number">1.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Producer-消息发送流程"><span class="toc-number">2.</span> <span class="toc-text">Producer 消息发送流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Producer官方实例"><span class="toc-number">3.</span> <span class="toc-text">Producer官方实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Fire-and-Fogret案例-（无所谓心态）"><span class="toc-number">3.1.</span> <span class="toc-text">Fire and Fogret案例 （无所谓心态）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#发送之后便不再理会发送结果"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">发送之后便不再理会发送结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步回调官方案例-（不阻塞）"><span class="toc-number">3.2.</span> <span class="toc-text">异步回调官方案例 （不阻塞）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JavaProducer的send方法会返回一个JavaFuture对象供用户稍后获取发送结果。这就是回调机制。"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">JavaProducer的send方法会返回一个JavaFuture对象供用户稍后获取发送结果。这就是回调机制。</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#同步发送官方案例-（阻塞）"><span class="toc-number">3.3.</span> <span class="toc-text">同步发送官方案例 （阻塞）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于事务发送官方案例-（原子性和幂等性）"><span class="toc-number">3.4.</span> <span class="toc-text">基于事务发送官方案例 （原子性和幂等性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可重试异常（继承RetriableException）"><span class="toc-number">3.5.</span> <span class="toc-text">可重试异常（继承RetriableException）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不可重试异常"><span class="toc-number">3.6.</span> <span class="toc-text">不可重试异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常的区别对待"><span class="toc-number">3.7.</span> <span class="toc-text">异常的区别对待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Producer的绅士关闭"><span class="toc-number">3.8.</span> <span class="toc-text">Producer的绅士关闭</span></a></li></div></div><div class="post-content"><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>kafka的Producer是线程安全的，用户可以非常非常放心的在多线程中使用。</p>
<p>但是官方建议：通常情况下，一个线程维护一个kafka 的producer的效率会更高。</p>
<h2 id="Producer-消息发送流程"><a href="#Producer-消息发送流程" class="headerlink" title="Producer 消息发送流程"></a>Producer 消息发送流程</h2><ul>
<li>第一步：封装ProducerRecord</li>
<li>第二步：分区器Partioner进行数据路由，选择某一个Topic分区。如果没有指定key，消息会被均匀的分配到所有分区。</li>
<li>第三步：确定好分区，就会找分区对应的leader，接下来就是副本同步机制。</li>
</ul>
<h2 id="Producer官方实例"><a href="#Producer官方实例" class="headerlink" title="Producer官方实例"></a>Producer官方实例</h2><h3 id="Fire-and-Fogret案例-（无所谓心态）"><a href="#Fire-and-Fogret案例-（无所谓心态）" class="headerlink" title="Fire and Fogret案例 （无所谓心态）"></a>Fire and Fogret案例 （无所谓心态）</h3><ul>
<li><h5 id="发送之后便不再理会发送结果"><a href="#发送之后便不再理会发送结果" class="headerlink" title="发送之后便不再理会发送结果"></a>发送之后便不再理会发送结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"> props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line"> props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line"> props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line"> props.put(<span class="string">"batch.size"</span>, <span class="number">16384</span>);</span><br><span class="line"> props.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line"> props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line"> props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"> props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line"> Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">     producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"my-topic"</span>, Integer.toString(i), Integer.toString(i)));</span><br><span class="line"></span><br><span class="line"> producer.close();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="异步回调官方案例-（不阻塞）"><a href="#异步回调官方案例-（不阻塞）" class="headerlink" title="异步回调官方案例 （不阻塞）"></a>异步回调官方案例 （不阻塞）</h3><ul>
<li><h5 id="JavaProducer的send方法会返回一个JavaFuture对象供用户稍后获取发送结果。这就是回调机制。"><a href="#JavaProducer的send方法会返回一个JavaFuture对象供用户稍后获取发送结果。这就是回调机制。" class="headerlink" title="JavaProducer的send方法会返回一个JavaFuture对象供用户稍后获取发送结果。这就是回调机制。"></a>JavaProducer的send方法会返回一个JavaFuture对象供用户稍后获取发送结果。这就是回调机制。</h5></li>
<li><p>Fully non-blocking usage can make use of the Callback parameter to provide a callback that will be invoked when the request is complete.</p>
</li>
<li><p>RecordMetadata 和 Exception 不可能同时为空，消息发送成功时，Exception为null，消息发送失败时，metadata为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;<span class="keyword">byte</span>[],<span class="keyword">byte</span>[]&gt; record = <span class="keyword">new</span> ProducerRecord&lt;<span class="keyword">byte</span>[],<span class="keyword">byte</span>[]&gt;(<span class="string">"the-topic"</span>, key, value);</span><br><span class="line"></span><br><span class="line">producer.send(myRecord,</span><br><span class="line">              <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception e)</span> </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         e.printStackTrace();</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         System.out.println(<span class="string">"The offset of the record we just sent is: "</span> + metadata.offset());</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="同步发送官方案例-（阻塞）"><a href="#同步发送官方案例-（阻塞）" class="headerlink" title="同步发送官方案例 （阻塞）"></a>同步发送官方案例 （阻塞）</h3><ul>
<li><p>通过 producer.send（record)返回Future对象，通过调用Future.get()进行无限等待结果返回。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.send（<span class="built_in">record</span>).<span class="keyword">get</span>()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="基于事务发送官方案例-（原子性和幂等性）"><a href="#基于事务发送官方案例-（原子性和幂等性）" class="headerlink" title="基于事务发送官方案例 （原子性和幂等性）"></a>基于事务发送官方案例 （原子性和幂等性）</h3><ul>
<li><p>From Kafka 0.11, the KafkaProducer supports two additional modes: the idempotent producerand the transactional producer. The idempotent producer strengthens Kafka’s deliverysemantics from at least once to exactly once delivery. In particular producer retries willno longer introduce duplicates. The transactional producer allows an application to sendmessages to multiple partitions (and topics!) atomically.</p>
</li>
<li><p>To enable idempotence, the enable.idempotence configuration must be set to true. If set,the retries config will default to Integer.MAX_VALUE and the acks config will default to all.There are no API changes for the idempotent producer, so existing applications will not need to be modified to take advantage of this feature.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(<span class="string">"transactional.id"</span>, <span class="string">"my-transactional-id"</span>);</span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props, <span class="keyword">new</span> StringSerializer(), <span class="keyword">new</span> StringSerializer());</span><br><span class="line"></span><br><span class="line">producer.initTransactions();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    producer.beginTransaction();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"my-topic"</span>, Integer.toString(i), Integer.toString(i)));</span><br><span class="line">    producer.commitTransaction();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ProducerFencedException | OutOfOrderSequenceException | AuthorizationException e) &#123;</span><br><span class="line">    <span class="comment">// We can't recover from these exceptions, so our only option is to close the producer and exit.</span></span><br><span class="line">    producer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">    <span class="comment">// For all other exceptions, just abort the transaction and try again.</span></span><br><span class="line">    producer.abortTransaction();</span><br><span class="line">&#125;</span><br><span class="line">producer.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p>As is hinted at in the example, there can be only one open transaction per producer. All messages sent between the beginTransaction() and commitTransaction() calls will be part of a single transaction. When the <a href="https://link.juejin.im?target=http%3A%2F%2Ftransactional.id" target="_blank" rel="noopener">transactional.id</a> is specified, all messages sent by the producer must be part of a transaction.</p>
</li>
</ul>
<h3 id="可重试异常（继承RetriableException）"><a href="#可重试异常（继承RetriableException）" class="headerlink" title="可重试异常（继承RetriableException）"></a>可重试异常（继承RetriableException）</h3><ul>
<li>LeaderNotAvailableException :分区的Leader副本不可用，这可能是换届选举导致的瞬时的异常，重试几次就可以恢复</li>
<li>NotControllerException:Controller主要是用来选择分区副本和每一个分区leader的副本信息，主要负责统一管理分区信息等，也可能是选举所致。</li>
<li>NetWorkerException :瞬时网络故障异常所致。</li>
</ul>
<h3 id="不可重试异常"><a href="#不可重试异常" class="headerlink" title="不可重试异常"></a>不可重试异常</h3><ul>
<li>SerializationException:序列化失败异常</li>
<li>RecordToolLargeException:消息尺寸过大导致。</li>
</ul>
<h3 id="异常的区别对待"><a href="#异常的区别对待" class="headerlink" title="异常的区别对待"></a>异常的区别对待</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">producer.send(myRecord,</span><br><span class="line">              <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception e)</span> </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span>(e ==<span class="keyword">null</span>)&#123;</span><br><span class="line">                          <span class="comment">//正常处理逻辑</span></span><br><span class="line">                          System.out.println(<span class="string">"The offset of the record we just sent is: "</span> + metadata.offset()); </span><br><span class="line">                          </span><br><span class="line">                      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                              </span><br><span class="line">                            <span class="keyword">if</span>(e <span class="keyword">instanceof</span> RetriableException) &#123;</span><br><span class="line">                               <span class="comment">//处理可重试异常</span></span><br><span class="line">                               ......</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">//处理不可重试异常</span></span><br><span class="line">                               ......</span><br><span class="line">                            &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Producer的绅士关闭"><a href="#Producer的绅士关闭" class="headerlink" title="Producer的绅士关闭"></a>Producer的绅士关闭</h3><ul>
<li>producer.close()：优先把消息处理完毕，优雅退出。</li>
<li>producer.close(timeout): 超时时，强制关闭。</li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>gaojintao999@163.com</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/09/15/kafka之Producer同步与异步消息发送及事务幂等性案例/">https://gjtmaster.github.io/2018/09/15/kafka之Producer同步与异步消息发送及事务幂等性案例/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>The author owns the copyright, please indicate the source reproduced.</li></ul></div><br><div class="tags"><a href="/tags/Kafka/">Kafka</a><a href="/tags/消息中间件/">消息中间件</a></div><div class="post-nav"><a class="pre" href="/2018/09/16/kafka Poll轮询机制与消费者组的重平衡分区策略剖析/">kafka Poll轮询机制与消费者组的重平衡分区策略剖析</a><a class="next" href="/2018/09/13/利用ogg实现oracle到kafka的增量数据实时同步/">利用ogg实现oracle到kafka的增量数据实时同步</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实时计算框架/">实时计算框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储格式/">数据存储格式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据的导入导出/">数据的导入导出</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志框架/">日志框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息中间件/">消息中间件</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Flink/" style="font-size: 15px;">Flink</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/Flink-on-Yarn/" style="font-size: 15px;">Flink on Yarn</a> <a href="/tags/实时计算/" style="font-size: 15px;">实时计算</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/FlinkSQL/" style="font-size: 15px;">FlinkSQL</a> <a href="/tags/Logback/" style="font-size: 15px;">Logback</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/消息中间件/" style="font-size: 15px;">消息中间件</a> <a href="/tags/Json/" style="font-size: 15px;">Json</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/内存回收/" style="font-size: 15px;">内存回收</a> <a href="/tags/ogg/" style="font-size: 15px;">ogg</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/Flink 进阶：Time 深度解析/">Flink 进阶：Time 深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/Flink 进阶：Flink Connector详解/">Flink 进阶：Flink Connector详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/16/Flink 进阶：增量 Checkpoint 详解/">Flink 进阶：增量 Checkpoint 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/15/Flink 进阶：Runtime 核心机制剖析/">Flink 进阶：Runtime 核心机制剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/FlinkSQL深度解析/">Flink SQL 深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/16/Flink on Yarn HA/">Flink On Yarn HA</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink使用Logback作为日志框架的相关配置/">Flink使用Logback作为日志框架的相关配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink On Yan集群部署/">Flink On Yarn集群部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink1.7.1与Kafka0.11.0.1/">Flink1.7.1与Kafka0.11.0.1</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/Kafka EOS 之事务性实现/">Kafka EOS 之事务性实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://matt33.com/" title="Matt's Blog" target="_blank">Matt's Blog</a><ul></ul><a href="https://www.haomwei.com/technology/maupassant-hexo.html" title="Maupassant's usage" target="_blank">Maupassant's usage</a><ul></ul><a href="https://www.jianshu.com/p/f4332764e8bd" title="hexo's usage" target="_blank">hexo's usage</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Joker's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>