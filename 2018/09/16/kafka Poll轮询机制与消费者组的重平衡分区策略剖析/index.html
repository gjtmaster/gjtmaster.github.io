<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="心有多大，舞台就有多大！"><title>kafka Poll轮询机制与消费者组的重平衡分区策略剖析 | Joker's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kafka Poll轮询机制与消费者组的重平衡分区策略剖析</h1><a id="logo" href="/.">Joker's Blog</a><p class="description">高金涛</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kafka Poll轮询机制与消费者组的重平衡分区策略剖析</h1><div class="post-meta">Sep 16, 2018<span> | </span><span class="category"><a href="/categories/消息中间件/">消息中间件</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Poll为什么要设置一个超时参数"><span class="toc-number">1.</span> <span class="toc-text">Poll为什么要设置一个超时参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位移精度"><span class="toc-number">2.</span> <span class="toc-text">位移精度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位移角色"><span class="toc-number">3.</span> <span class="toc-text">位移角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位移管理"><span class="toc-number">4.</span> <span class="toc-text">位移管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#但是具体的reblance分区分配策略目前已经交由Consumer客户端。这样就解耦了组管理和分区分配。"><span class="toc-number">4.0.1.</span> <span class="toc-text">但是具体的reblance分区分配策略目前已经交由Consumer客户端。这样就解耦了组管理和分区分配。</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#reblance的触发条件"><span class="toc-number">5.</span> <span class="toc-text">reblance的触发条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reblance-分配策略"><span class="toc-number">6.</span> <span class="toc-text">reblance 分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#range分区分配策略"><span class="toc-number">6.1.</span> <span class="toc-text">range分区分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#round-robin分区分配策略"><span class="toc-number">6.2.</span> <span class="toc-text">round-robin分区分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StickyAssignor分区分配策略（摘录）"><span class="toc-number">6.3.</span> <span class="toc-text">StickyAssignor分区分配策略（摘录）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reblance-generation-（代代不同）"><span class="toc-number">7.</span> <span class="toc-text">reblance generation （代代不同）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reblance-扫尾工作"><span class="toc-number">8.</span> <span class="toc-text">reblance 扫尾工作</span></a></li></div></div><div class="post-content"><p>注意本文采用最新版本进行Kafka的内核原理剖析，新版本每一个Consumer通过独立的线程，来管理多个Socket连接，即同时与多个broker通信实现消息的并行读取。这就是新版的技术革新。类似于Linux I/O模型或者Select NIO 模型。</p>
<h2 id="Poll为什么要设置一个超时参数"><a href="#Poll为什么要设置一个超时参数" class="headerlink" title="Poll为什么要设置一个超时参数"></a>Poll为什么要设置一个超时参数</h2><ul>
<li>条件：</li>
<li>1：获取足够多的可用数据</li>
<li>2：等待时间超过指定的超时时间。</li>
<li>目的在于让Consumer主线程定期的””苏醒”去做其他事情。比如：定期的执行常规任务，（比如写日志，写库等）。</li>
<li>获取消息，然后执行业务逻辑。</li>
</ul>
<h2 id="位移精度"><a href="#位移精度" class="headerlink" title="位移精度"></a>位移精度</h2><ul>
<li>最少一次 -&gt;  消息会被重复处理</li>
<li>最多一次 -&gt;  消息会丢失，但不会被重复处理。</li>
<li>精确一次 -&gt; 一定会被处理，且也只会处理一次。</li>
</ul>
<h2 id="位移角色"><a href="#位移角色" class="headerlink" title="位移角色"></a>位移角色</h2><ul>
<li>上次提交位移 ：last committed offset</li>
<li>当前位置 ：current position</li>
<li>水位 ： High watermark</li>
<li>日志终端位移： （Log End Offset）</li>
</ul>
<h2 id="位移管理"><a href="#位移管理" class="headerlink" title="位移管理"></a>位移管理</h2><p>consumer的位移提交最终会向group coordinator来提交，不过这里重点需要重新说明一下：组协调者coordinator负责管理所有的Consumer实例。而且coordinator运行在broker上（通过选举出某个broker），不过请注意新版本coordinator只负责做组管理。</p>
<h4 id="但是具体的reblance分区分配策略目前已经交由Consumer客户端。这样就解耦了组管理和分区分配。"><a href="#但是具体的reblance分区分配策略目前已经交由Consumer客户端。这样就解耦了组管理和分区分配。" class="headerlink" title="但是具体的reblance分区分配策略目前已经交由Consumer客户端。这样就解耦了组管理和分区分配。"></a>但是具体的reblance分区分配策略目前已经交由Consumer客户端。这样就解耦了组管理和分区分配。</h4><p>权利下放的优势：</p>
<ul>
<li>如果需要分配就貌似需要重启整个kafka集群。</li>
<li>在Consumer端可以定制分区分配策略。</li>
<li>每一个consumer位移提交时，都会向_consumer_offsets对应的分区上追加写入一条消息。如果某一个consumer为同一个group的同一个topic同一个分区提交多次位移，很显然我们只关心最新一次提交的位移。</li>
</ul>
<h2 id="reblance的触发条件"><a href="#reblance的触发条件" class="headerlink" title="reblance的触发条件"></a>reblance的触发条件</h2><ul>
<li>组订阅发生变更，比如基于正则表达式订阅，当匹配到新的topic创建时，组的订阅就会发生变更。</li>
<li>组的topic分区数发生变更，通过命令行脚本增加了订阅topic的分区数。</li>
<li>组成员发生变更：新加入组以及离开组。</li>
</ul>
<h2 id="reblance-分配策略"><a href="#reblance-分配策略" class="headerlink" title="reblance 分配策略"></a>reblance 分配策略</h2><h3 id="range分区分配策略"><a href="#range分区分配策略" class="headerlink" title="range分区分配策略"></a>range分区分配策略</h3><p>举例如下：一个拥有十个分区（0,1,2…..,9）的topic，相同group拥有三个consumerid为a,b,c的消费者：</p>
<ul>
<li><p>consumer a分配对应的分区号为[0,4),即0，1，2，3前面四个分区</p>
</li>
<li><p>consumer b 分配对应分区4，5，6中间三个分区</p>
</li>
<li><p>consumer c 分配对应分区7，8，9最后三个分区。</p>
<p>class RangeAssignor() extends PartitionAssignor with Logging {</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assign</span></span>(ctx: <span class="type">AssignmentContext</span>) = &#123;</span><br><span class="line">  <span class="keyword">val</span> valueFactory = (topic: <span class="type">String</span>) =&gt; <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">TopicAndPartition</span>, <span class="type">ConsumerThreadId</span>]</span><br><span class="line">  <span class="keyword">val</span> partitionAssignment =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Pool</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">TopicAndPartition</span>, <span class="type">ConsumerThreadId</span>]](<span class="type">Some</span>(valueFactory))</span><br><span class="line">  <span class="keyword">for</span> (topic &lt;- ctx.myTopicThreadIds.keySet) &#123;</span><br><span class="line">    <span class="keyword">val</span> curConsumers = ctx.consumersForTopic(topic)</span><br><span class="line">    <span class="keyword">val</span> curPartitions: <span class="type">Seq</span>[<span class="type">Int</span>] = ctx.partitionsForTopic(topic)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> nPartsPerConsumer = curPartitions.size / curConsumers.size</span><br><span class="line">    <span class="keyword">val</span> nConsumersWithExtraPart = curPartitions.size % curConsumers.size</span><br><span class="line"></span><br><span class="line">    info(<span class="string">"Consumer "</span> + ctx.consumerId + <span class="string">" rebalancing the following partitions: "</span> + curPartitions +</span><br><span class="line">      <span class="string">" for topic "</span> + topic + <span class="string">" with consumers: "</span> + curConsumers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (consumerThreadId &lt;- curConsumers) &#123;</span><br><span class="line">      <span class="keyword">val</span> myConsumerPosition = curConsumers.indexOf(consumerThreadId)</span><br><span class="line">      assert(myConsumerPosition &gt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">val</span> startPart = nPartsPerConsumer * myConsumerPosition + myConsumerPosition.min(nConsumersWithExtraPart)</span><br><span class="line">      <span class="keyword">val</span> nParts = nPartsPerConsumer + (<span class="keyword">if</span> (myConsumerPosition + <span class="number">1</span> &gt; nConsumersWithExtraPart) <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *   Range-partition the sorted partitions to consumers for better locality.</span></span><br><span class="line"><span class="comment">       *  The first few consumers pick up an extra partition, if any.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (nParts &lt;= <span class="number">0</span>)</span><br><span class="line">        warn(<span class="string">"No broker partitions consumed by consumer thread "</span> + consumerThreadId + <span class="string">" for topic "</span> + topic)</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i &lt;- startPart until startPart + nParts) &#123;</span><br><span class="line">          <span class="keyword">val</span> partition = curPartitions(i)</span><br><span class="line">          info(consumerThreadId + <span class="string">" attempting to claim partition "</span> + partition)</span><br><span class="line">          <span class="comment">// record the partition ownership decision</span></span><br><span class="line">          <span class="keyword">val</span> assignmentForConsumer = partitionAssignment.getAndMaybePut(consumerThreadId.consumer)</span><br><span class="line">          assignmentForConsumer += (<span class="type">TopicAndPartition</span>(topic, partition) -&gt; consumerThreadId)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>源码剖析如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curConsumers=(a,b,c)</span><br><span class="line">curPartitions=(0,1,2,3,4,5,6,7,8,9)</span><br><span class="line">nPartsPerConsumer=10/3  =3</span><br><span class="line">nConsumersWithExtraPart=10%3  =1</span><br><span class="line"></span><br><span class="line"><span class="section">a:</span></span><br><span class="line">myConsumerPosition= curConsumers.indexof(a) =0</span><br><span class="line">startPart= 3*0+0.min(1) = 0</span><br><span class="line">nParts = 3+(if (0 + 1 &gt; 1) 0 <span class="keyword">else</span> 1)=3+1=4</span><br><span class="line"><span class="section">b:</span></span><br><span class="line">myConsumerPosition=1</span><br><span class="line"><span class="section">c:</span></span><br><span class="line">myConsumerPosition</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="round-robin分区分配策略"><a href="#round-robin分区分配策略" class="headerlink" title="round-robin分区分配策略"></a>round-robin分区分配策略</h3><p>如果同一个消费组内所有的消费者的订阅信息都是相同的，那么RoundRobinAssignor策略的分区分配会是均匀的。举例如下：假设消费组中有2个消费者C0和C1，都订阅了主题topic0 和 topic1，并且每个主题都有3个分区，进行hashCode 排序 后，顺序为：topic0_0、topic0_1、topic0_2、topic1_0、topic1_1、topic1_2。最终的分配结果为：</p>
<p>消费者consumer0：topic0_0、topic0_2 、 topic1_1</p>
<p>消费者consumer1：topic0_1、topic1_0、 topic1_2</p>
<p>使用RoundRobin策略有两个前提条件必须满足：</p>
<ul>
<li>同一个Consumer Group里面的所有消费者的num.streams必须相等；</li>
<li>每个消费者订阅的主题必须相同。</li>
</ul>
<p>所以这里假设前面提到的2个消费者的num.streams = 2。RoundRobin策略的工作原理：将所有主题的分区组成 TopicAndPartition 列表，然后对 TopicAndPartition 列表按照 hashCode 进行排序，最后按照round-robin风格将分区分别分配给不同的消费者线程。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> allTopicPartitions = ctx.partitionsForTopic.flatMap &#123; <span class="keyword">case</span>(topic, partitions) =&gt;</span><br><span class="line">	  info(<span class="string">"Consumer %s rebalancing the following partitions for topic %s: %s"</span></span><br><span class="line">	       .format(ctx.consumerId, topic, partitions))</span><br><span class="line">	  partitions.map(partition =&gt; &#123;</span><br><span class="line">	    <span class="type">TopicAndPartition</span>(topic, partition)</span><br><span class="line">	  &#125;)</span><br><span class="line">	&#125;.toSeq.sortWith((topicPartition1, topicPartition2) =&gt; &#123;</span><br><span class="line">	  <span class="comment">/*</span></span><br><span class="line"><span class="comment">	   * Randomize the order by taking the hashcode to reduce the likelihood of all partitions of a given topic ending</span></span><br><span class="line"><span class="comment">	   * up on one consumer (if it has a high enough stream count).</span></span><br><span class="line"><span class="comment">	   */</span></span><br><span class="line">	  topicPartition1.toString.hashCode &lt; topicPartition2.toString.hashCode</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="StickyAssignor分区分配策略（摘录）"><a href="#StickyAssignor分区分配策略（摘录）" class="headerlink" title="StickyAssignor分区分配策略（摘录）"></a>StickyAssignor分区分配策略（摘录）</h3><ul>
<li>分区的分配要尽可能的均匀；</li>
<li>分区的分配尽可能的与上次分配的保持相同。当两者发生冲突时，第一个目标优先于第二个目标。鉴于这两个目标，StickyAssignor策略的具体实现要比RangeAssignor和RoundRobinAssignor这两种分配策略要复杂很多。</li>
</ul>
<p>假设消费组内有3个消费者：C0、C1和C2，它们都订阅了4个主题：t0、t1、t2、t3，并且每个主题有2个分区，也就是说整个消费组订阅了t0p0、t0p1、t1p0、t1p1、t2p0、t2p1、t3p0、t3p1这8个分区。最终的分配结果如下：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消费者C0：t0p0、t1p1、t3p0</span><br><span class="line">消费者C1：t0p1、t2p0、t3p1</span><br><span class="line">消费者C2：t1p0、t2p1</span><br></pre></td></tr></table></figure>

<p>假设此时消费者C1脱离了消费组，那么消费组就会执行再平衡操作，进而消费分区会重新分配。如果采用RoundRobinAssignor策略，那么此时的分配结果如下：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消费者C0：t0p0、t1p0、t2p0、t3p0</span><br><span class="line">消费者C2：t0p1、t1p1、t2p1、t3p1</span><br></pre></td></tr></table></figure>

<p>RoundRobinAssignor策略会按照消费者C0和C2进行重新轮询分配。而如果此时使用的是StickyAssignor策略，那么分配结果为：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消费者C0：t0p0、t1p1、t3p0、t2p0</span><br><span class="line">消费者C2：t1p0、t2p1、t0p1、t3p1</span><br></pre></td></tr></table></figure>

<p>可以看到分配结果中保留了上一次分配中对于消费者C0和C2的所有分配结果，并将原来消费者C1的“负担”分配给了剩余的两个消费者C0和C2，最终C0和C2的分配仍然保持了均衡。</p>
<p>如果发生分区重分配，那么对于同一个分区而言有可能之前的消费者和新指派的消费者不是同一个，对于之前消费者进行到一半的处理还要在新指派的消费者中再次复现一遍，这显然很浪费系统资源。StickyAssignor策略如同其名称中的“sticky”一样，让分配策略具备一定的“粘性”，尽可能地让前后两次分配相同，进而减少系统资源的损耗以及其它异常情况的发生。</p>
<h2 id="reblance-generation-（代代不同）"><a href="#reblance-generation-（代代不同）" class="headerlink" title="reblance generation （代代不同）"></a>reblance generation （代代不同）</h2><p>主要作用在于防止无效的offset提交，原因在于若上一届的consumer成员因为某些原因延迟提交了offset,同时被踢出group组，那么新一届的group组成员分区分配结束后，老一届的consumer再次提交老的offset就会出问题。因此采用reblance generation ，老的请求就会被拒绝。</p>
<h2 id="reblance-扫尾工作"><a href="#reblance-扫尾工作" class="headerlink" title="reblance 扫尾工作"></a>reblance 扫尾工作</h2><p>每一次reblance操作之前，都会检查用户是否设置了自动提交位移，如果是，则帮助用户提交。如没有设置，会在监听器中回调用户的提交程序。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>gaojintao999@163.com</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/09/16/kafka Poll轮询机制与消费者组的重平衡分区策略剖析/">https://gjtmaster.github.io/2018/09/16/kafka Poll轮询机制与消费者组的重平衡分区策略剖析/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>The author owns the copyright, please indicate the source reproduced.</li></ul></div><br><div class="tags"><a href="/tags/Kafka/">Kafka</a><a href="/tags/消息中间件/">消息中间件</a></div><div class="post-nav"><a class="pre" href="/2018/09/17/kafka rebalance 机制与Consumer多种消费模式案例应用实战/">kafka rebalance机制与Consumer多种消费模式案例</a><a class="next" href="/2018/09/15/kafka之Producer同步与异步消息发送及事务幂等性案例/">kafka之Producer同步与异步消息发送及事务幂等性案例</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实时计算框架/">实时计算框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储格式/">数据存储格式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据的导入导出/">数据的导入导出</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志框架/">日志框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息中间件/">消息中间件</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Flink/" style="font-size: 15px;">Flink</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/Flink-on-Yarn/" style="font-size: 15px;">Flink on Yarn</a> <a href="/tags/实时计算/" style="font-size: 15px;">实时计算</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/FlinkSQL/" style="font-size: 15px;">FlinkSQL</a> <a href="/tags/Logback/" style="font-size: 15px;">Logback</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/消息中间件/" style="font-size: 15px;">消息中间件</a> <a href="/tags/Json/" style="font-size: 15px;">Json</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/内存回收/" style="font-size: 15px;">内存回收</a> <a href="/tags/ogg/" style="font-size: 15px;">ogg</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/Flink 进阶：Time 深度解析/">Flink 进阶：Time 深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/Flink 进阶：Flink Connector详解/">Flink 进阶：Flink Connector详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/16/Flink 进阶：增量 Checkpoint 详解/">Flink 进阶：增量 Checkpoint 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/15/Flink 进阶：Runtime 核心机制剖析/">Flink 进阶：Runtime 核心机制剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/FlinkSQL深度解析/">Flink SQL 深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/16/Flink on Yarn HA/">Flink On Yarn HA</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink使用Logback作为日志框架的相关配置/">Flink使用Logback作为日志框架的相关配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink On Yan集群部署/">Flink On Yarn集群部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink1.7.1与Kafka0.11.0.1/">Flink1.7.1与Kafka0.11.0.1</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/Kafka EOS 之事务性实现/">Kafka EOS 之事务性实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://matt33.com/" title="Matt's Blog" target="_blank">Matt's Blog</a><ul></ul><a href="https://www.haomwei.com/technology/maupassant-hexo.html" title="Maupassant's usage" target="_blank">Maupassant's usage</a><ul></ul><a href="https://www.jianshu.com/p/f4332764e8bd" title="hexo's usage" target="_blank">hexo's usage</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Joker's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>