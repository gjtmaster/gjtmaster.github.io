<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="心有多大，舞台就有多大！"><title>kafka集群Controller竞选与责任设计思路架构详解 | Joker's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kafka集群Controller竞选与责任设计思路架构详解</h1><a id="logo" href="/.">Joker's Blog</a><p class="description">高金涛</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kafka集群Controller竞选与责任设计思路架构详解</h1><div class="post-meta">Sep 21, 2018<span> | </span><span class="category"><a href="/categories/消息中间件/">消息中间件</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#无所不能的Controller"><span class="toc-number">1.</span> <span class="toc-text">无所不能的Controller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReplicaStateMachine-（ZK持久化副本分配方案）"><span class="toc-number">2.</span> <span class="toc-text">ReplicaStateMachine （ZK持久化副本分配方案）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#partitionStateMachine-（根据副本分配方案创建分区）"><span class="toc-number">3.</span> <span class="toc-text">partitionStateMachine （根据副本分配方案创建分区）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Controller职责所在-监听znode状态变化做执行"><span class="toc-number">4.</span> <span class="toc-text">Controller职责所在(监听znode状态变化做执行)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Controller与Broker之间的通信机制（NIO-select）"><span class="toc-number">5.</span> <span class="toc-text">Controller与Broker之间的通信机制（NIO select）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ControllerContext数据组件"><span class="toc-number">6.</span> <span class="toc-text">ControllerContext数据组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><h2 id="无所不能的Controller"><a href="#无所不能的Controller" class="headerlink" title="无所不能的Controller"></a>无所不能的Controller</h2><p><img src="https://user-gold-cdn.xitu.io/2018/12/2/1676dd7505afda5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li><p>某一个broker被选举出来承担特殊的角色，就是控制器Controller。</p>
</li>
<li><p>Leader会向zookeeper上注册Watcher，其他broker几乎不用监听zookeeper的状态变化。</p>
</li>
<li><p>Controller集群就是用来管理和协调Kafka集群的，具体就是管理集群中所有分区的状态和分区对应副本的状态。</p>
</li>
<li><p>每一个Kafka集群任意时刻都只能有一个controller，当集群启动的时候，所有的broker都会参与到controller的竞选，最终只能有一个broker胜出。</p>
</li>
<li><p>Controller维护的状态分为两类：1：管理每一台Broker上对应的分区副本。2：管理每一个Topic分区的状态。</p>
</li>
<li><p>KafkaController 核心代码，其中包含副本状态机和分区状态机</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaController</span>(<span class="params">val config : <span class="type">KafkaConfig</span>, zkClient: <span class="type">ZkClient</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">val brokerState: <span class="type">BrokerState</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.logIdent = <span class="string">"[Controller "</span> + config.brokerId + <span class="string">"]: "</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> stateChangeLogger = <span class="type">KafkaController</span>.stateChangeLogger</span><br><span class="line">    <span class="keyword">val</span> controllerContext = <span class="keyword">new</span> <span class="type">ControllerContext</span>(zkClient, config.zkSessionTimeoutMs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> partitionStateMachine = <span class="keyword">new</span> <span class="type">PartitionStateMachine</span>(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">val</span> replicaStateMachine = <span class="keyword">new</span> <span class="type">ReplicaStateMachine</span>(<span class="keyword">this</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> controllerElector = <span class="keyword">new</span> <span class="type">ZookeeperLeaderElector</span>(controllerContext, <span class="type">ZkUtils</span>.<span class="type">ControllerPath</span>, onControllerFailover,</span><br><span class="line">    onControllerResignation, config.brokerId)</span><br><span class="line">    <span class="comment">// have a separate scheduler for the controller to be able to start and stop independently of the</span></span><br><span class="line">    <span class="comment">// kafka server</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> autoRebalanceScheduler = <span class="keyword">new</span> <span class="type">KafkaScheduler</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> deleteTopicManager: <span class="type">TopicDeletionManager</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> offlinePartitionSelector = <span class="keyword">new</span> <span class="type">OfflinePartitionLeaderSelector</span>(controllerContext, config)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> reassignedPartitionLeaderSelector = <span class="keyword">new</span> <span class="type">ReassignedPartitionLeaderSelector</span>(controllerContext)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> preferredReplicaPartitionLeaderSelector = <span class="keyword">new</span> <span class="type">PreferredReplicaPartitionLeaderSelector</span>(controllerContext)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> controlledShutdownPartitionLeaderSelector = <span class="keyword">new</span> <span class="type">ControlledShutdownLeaderSelector</span>(controllerContext)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> brokerRequestBatch = <span class="keyword">new</span> <span class="type">ControllerBrokerRequestBatch</span>(<span class="keyword">this</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> partitionReassignedListener = <span class="keyword">new</span> <span class="type">PartitionsReassignedListener</span>(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> preferredReplicaElectionListener = <span class="keyword">new</span> <span class="type">PreferredReplicaElectionListener</span>(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>KafkaController中共定义了五种selector选举器</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、ReassignedPartitionLeaderSelector</span><br><span class="line">从可用的ISR中选取第一个作为<span class="built_in">leader</span>，把当前的ISR作为新的ISR，将重分配的副本集合作为接收LeaderAndIsr请求的副本集合。</span><br><span class="line"><span class="number">2</span>、PreferredReplicaPartitionLeaderSelector</span><br><span class="line">如果从assignedReplicas取出的第一个副本就是分区<span class="built_in">leader</span>的话，则抛出异常，否则将第一个副本设置为分区<span class="built_in">leader</span>。</span><br><span class="line"><span class="number">3</span>、ControlledShutdownLeaderSelector</span><br><span class="line">将ISR中处于关闭状态的副本从集合中去除掉，返回一个新新的ISR集合，然后选取第一个副本作为<span class="built_in">leader</span>，然后令当前AR作为接收LeaderAndIsr请求的副本。</span><br><span class="line"><span class="number">4</span>、NoOpLeaderSelector</span><br><span class="line">原则上不做任何事情，返回当前的<span class="built_in">leader</span>和isr。</span><br><span class="line"><span class="number">5</span>、OfflinePartitionLeaderSelector</span><br><span class="line">从活着的ISR中选择一个broker作为<span class="built_in">leader</span>，如果ISR中没有活着的副本，则从assignedReplicas中选择一个副本作为<span class="built_in">leader</span>，<span class="built_in">leader</span>选举成功后注册到Zookeeper中，并更新所有的缓存。</span><br></pre></td></tr></table></figure>
</li>
<li><p>kafka修改分区和副本数</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">..<span class="regexp">/bin/</span>kafka-topics.sh --zookeeper <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2181</span> --describe  --topic test1</span><br><span class="line"></span><br><span class="line"><span class="string">Topic:</span>test1       <span class="string">PartitionCount:</span><span class="number">3</span>        <span class="string">ReplicationFactor:</span><span class="number">2</span>     <span class="string">Configs:</span></span><br><span class="line"><span class="string">Topic:</span> test1      <span class="string">Partition:</span> <span class="number">0</span>    <span class="string">Leader:</span> <span class="number">2</span>       <span class="string">Replicas:</span> <span class="number">2</span>,<span class="number">4</span>   <span class="string">Isr:</span> <span class="number">2</span>,<span class="number">4</span></span><br><span class="line"><span class="string">Topic:</span> test1      <span class="string">Partition:</span> <span class="number">1</span>    <span class="string">Leader:</span> <span class="number">3</span>       <span class="string">Replicas:</span> <span class="number">3</span>,<span class="number">5</span>   <span class="string">Isr:</span> <span class="number">3</span>,<span class="number">5</span></span><br><span class="line"><span class="string">Topic:</span> test1      <span class="string">Partition:</span> <span class="number">2</span>    <span class="string">Leader:</span> <span class="number">4</span>       <span class="string">Replicas:</span> <span class="number">4</span>,<span class="number">1</span>   <span class="string">Isr:</span> <span class="number">4</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>topic 分区扩容</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">./kafka-topics.sh</span> <span class="params">--zookeeper</span> 127.0.0.1<span class="function">:2181</span> -alter <span class="params">--partitions</span> 4 <span class="params">--topic</span> test1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="ReplicaStateMachine-（ZK持久化副本分配方案）"><a href="#ReplicaStateMachine-（ZK持久化副本分配方案）" class="headerlink" title="ReplicaStateMachine （ZK持久化副本分配方案）"></a>ReplicaStateMachine （ZK持久化副本分配方案）</h2><ul>
<li><p>Replica有7种状态:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="string">NewReplica:</span> 在partition reassignment期间KafkaController创建New replica</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="string">OnlineReplica:</span> 当一个replica变为一个parition的assingned replicas时</span><br><span class="line">其状态变为OnlineReplica, 即一个有效的OnlineReplica</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> Online状态的parition才能转变为leader或isr中的一员</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="string">OfflineReplica:</span> 当一个broker down时, 上面的replica也随之die, 其状态转变为Onffline;</span><br><span class="line"><span class="string">ReplicaDeletionStarted:</span> 当一个replica的删除操作开始时,其状态转变为ReplicaDeletionStarted</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="string">ReplicaDeletionSuccessful:</span> Replica成功删除后,其状态转变为ReplicaDeletionSuccessful</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="string">ReplicaDeletionIneligible:</span> Replica成功失败后,其状态转变为ReplicaDeletionIneligible</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> <span class="string">NonExistentReplica:</span>  Replica成功删除后, 从ReplicaDeletionSuccessful状态转变为NonExistentReplica状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReplicaStateMachine 所在文件: core/src/main/scala/kafka/controller/ReplicaStateMachine.scala</p>
</li>
<li><p>startup: 启动ReplicaStateMachine</p>
</li>
<li><p>initializeReplicaState: 初始化每个replica的状态, 如果replica所在的broker是live状态,则此replica的状态为OnlineReplica。</p>
</li>
<li><p>处理可以转换到Online状态的Replica, handleStateChanges(controllerContext.allLiveReplicas(), OnlineReplica), 并且发送LeaderAndIsrRequest到各broker nodes: handleStateChanges(controllerContext.allLiveReplicas(), OnlineReplica)</p>
</li>
<li><p>当创建某个topic时，该topic下所有分区的所有副本都是NonExistent。</p>
</li>
<li><p>当controller加载Zookeeper中该topic每一个分区的所有副本信息到内存中，同时将副本的状态变更为New。</p>
</li>
<li><p>之后controller选择该分区副本列表中的第一个副本作为分区的leader副本并设置所有副本进入ISR，然后在Zookeeper中持久化该决定。</p>
</li>
<li><p>一旦确定了分区的Leader和ISR之后，controller会将这些消息以请求的方式发送给所有的副本。</p>
</li>
<li><p>同时将这些副本状态同步到集群的所有broker上以便让他们知晓。</p>
</li>
<li><p>最后controller 会把分区的所有副本状态设置为Online。</p>
</li>
</ul>
<h2 id="partitionStateMachine-（根据副本分配方案创建分区）"><a href="#partitionStateMachine-（根据副本分配方案创建分区）" class="headerlink" title="partitionStateMachine （根据副本分配方案创建分区）"></a>partitionStateMachine （根据副本分配方案创建分区）</h2><ul>
<li><p>Partition有如下四种状态</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NonExistentPartition:</span> 这个partition还没有被创建或者是创建后又被删除了<span class="comment">;</span></span><br><span class="line"><span class="symbol">NewPartition:</span> 这个parition已创建, replicas也已分配好,但leader/isr还未就绪<span class="comment">;</span></span><br><span class="line"><span class="symbol">OnlinePartition:</span> 这个partition的leader选好<span class="comment">;</span></span><br><span class="line"><span class="symbol">OfflinePartition:</span> 这个partition的leader挂了,这个parition状态为OfflinePartition<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当创建Topic时，controller负责创建分区对象，它首先会短暂的将所有分区状态设置为NonExistent。</p>
</li>
<li><p>之后读取Zookeeper副本分配方案，然后令分区状态设置为NewPartion。</p>
</li>
<li><p>处于NewPartion状态的分区尚未有leader和ISR，因此Controller会初始化leader和ISR信息并设置分区状态为OnlinePartion，此时分区正常工作。</p>
</li>
</ul>
<h2 id="Controller职责所在-监听znode状态变化做执行"><a href="#Controller职责所在-监听znode状态变化做执行" class="headerlink" title="Controller职责所在(监听znode状态变化做执行)"></a>Controller职责所在(监听znode状态变化做执行)</h2><ul>
<li>UpdateMetadataRequest：更新元数据请求（比如：topic有多少个分区，每一个分区的leader在哪一台broker上以及分区的副本列表），随着集群的运行，这部分信息随时都可能变更，一旦发生变更，controller会将最新的元数据广播给所有存活的broker。具体方式就是给所有broker发送UpdateMetadataRequest请求</li>
<li>CreateTopics: 创建topic请求。当前不管是通过API方式、脚本方式（–create）抑或是CreateTopics请求方式来创建topic，做法几乎都是在Zookeeper的/brokers/topics下创建znode来触发创建逻辑，而controller会监听该path下的变更来执行真正的“创建topic”逻辑</li>
<li>DeleteTopics：删除topic请求。和CreateTopics类似，也是通过创建Zookeeper下的/admin/delete_topics/节点来触发删除topic，主要逻辑有：1：停止所有副本运行。2：删除所有副本的日志数据。3：移除zk上的 /admin/delete_topics/节点。</li>
<li>分区重分配：即kafka-reassign-partitions脚本做的事情。同样是与Zookeeper结合使用，脚本写入/admin/reassign_partitions节点来触发，controller负责按照方案分配分区。执行过程是：先扩展再伸缩机制（旧副本和新副本集合同时存在）。</li>
<li>Preferred leader分配：调整分区leader副本，preferred leader选举当前有两种触发方式：1. 自动触发(auto.leader.rebalance.enable = true)，controller会自动调整Preferred leader。2. kafka-preferred-replica-election脚本触发。两者步骤相同，都是向Zookeeper的/admin/preferred_replica_election写数据，controller提取数据执行preferred leader分配</li>
<li>分区扩展：即增加topic分区数。标准做法也是通过kafka-reassign-partitions脚本完成，不过用户可直接往Zookeeper中写数据来实现，比如直接把新增分区的副本集合写入到/brokers/topics/下，然后controller会为你自动地选出leader并增加分区</li>
<li>集群扩展：新增broker时Zookeeper中/brokers/ids下会新增znode，controller自动完成服务发现的工作</li>
<li>broker崩溃：同样地，controller通过Zookeeper可实时侦测broker状态。一旦有broker挂掉了，controller可立即感知并为受影响分区选举新的leader</li>
<li>ControlledShutdown：broker除了崩溃，还能“优雅”地退出。broker一旦自行终止，controller会接收到一个ControlledShudownRequest请求，然后controller会妥善处理该请求并执行各种收尾工作</li>
<li>Controller leader选举：controller必然要提供自己的leader选举以防这个全局唯一的组件崩溃宕机导致服务中断。这个功能也是通过Zookeeper的帮助实现的。</li>
</ul>
<h2 id="Controller与Broker之间的通信机制（NIO-select）"><a href="#Controller与Broker之间的通信机制（NIO-select）" class="headerlink" title="Controller与Broker之间的通信机制（NIO select）"></a>Controller与Broker之间的通信机制（NIO select）</h2><ul>
<li>controller启动时会为集群中的所有Broker创建一个专属的Socket连接，假如有100台broker机器，那么controller会创建100个Socket连接。新版本目前统一使用NIO select ，实际上还是要维护100个线程。</li>
</ul>
<h2 id="ControllerContext数据组件"><a href="#ControllerContext数据组件" class="headerlink" title="ControllerContext数据组件"></a>ControllerContext数据组件</h2><ul>
<li>controller的缓存，可谓是最重要的数据组件了，ControllerContext汇总了Zookeeper中关于kafka集群中所有元数据信息，是controller能够正确提供服务的基础。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/2/1676dd70918f80a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>kafka集群Controller主要通过ZK持久化副本分配方案，根据副本分配方案创建分区，监听ZK znode状态变化做执行处理，维护分区和副本ISR机制稳定运行。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>gaojintao999@163.com</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/09/21/kafka集群Controller竞选与责任设计思路架构详解/">https://gjtmaster.github.io/2018/09/21/kafka集群Controller竞选与责任设计思路架构详解/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>The author owns the copyright, please indicate the source reproduced.</li></ul></div><br><div class="tags"><a href="/tags/Kafka/">Kafka</a><a href="/tags/消息中间件/">消息中间件</a></div><div class="post-nav"><a class="pre" href="/2018/09/23/kafka ISR设计及水印与leader epoch副本同步机制深入剖析/">kafka ISR设计及水印与leader epoch副本同步机制深入剖析</a><a class="next" href="/2018/09/20/kafka精确一次语义EOS的原理深入剖析/">kafka精确一次语义EOS的原理深入剖析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实时计算框架/">实时计算框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储格式/">数据存储格式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据的导入导出/">数据的导入导出</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志框架/">日志框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息中间件/">消息中间件</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Flink/" style="font-size: 15px;">Flink</a> <a href="/tags/实时计算/" style="font-size: 15px;">实时计算</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/Flink-on-Yarn/" style="font-size: 15px;">Flink on Yarn</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/消息中间件/" style="font-size: 15px;">消息中间件</a> <a href="/tags/Logback/" style="font-size: 15px;">Logback</a> <a href="/tags/Json/" style="font-size: 15px;">Json</a> <a href="/tags/FlinkSQL/" style="font-size: 15px;">FlinkSQL</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/内存回收/" style="font-size: 15px;">内存回收</a> <a href="/tags/ogg/" style="font-size: 15px;">ogg</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/Flink 进阶：Time 深度解析/">Flink 进阶：Time 深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/Flink 进阶：Flink Connector详解/">Flink 进阶：Flink Connector详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/16/Flink 进阶：增量 Checkpoint 详解/">Flink 进阶：增量 Checkpoint 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/15/Flink 进阶：Runtime 核心机制剖析/">Flink 进阶：Runtime 核心机制剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/FlinkSQL深度解析/">Flink SQL 深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/16/Flink on Yarn HA/">Flink On Yarn HA</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink使用Logback作为日志框架的相关配置/">Flink使用Logback作为日志框架的相关配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink On Yan集群部署/">Flink On Yarn集群部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink1.7.1与Kafka0.11.0.1/">Flink1.7.1与Kafka0.11.0.1</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/消息中间件高级技术要点企业级架构深入分析/">消息中间件高级技术要点企业级架构深入分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://matt33.com/" title="Matt's Blog" target="_blank">Matt's Blog</a><ul></ul><a href="https://www.haomwei.com/technology/maupassant-hexo.html" title="Maupassant's usage" target="_blank">Maupassant's usage</a><ul></ul><a href="https://www.jianshu.com/p/f4332764e8bd" title="hexo's usage" target="_blank">hexo's usage</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Joker's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>