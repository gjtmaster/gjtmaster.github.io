<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="心有多大，舞台就有多大！"><title>kafka ISR设计及水印与leader epoch副本同步机制深入剖析 | Joker's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kafka ISR设计及水印与leader epoch副本同步机制深入剖析</h1><a id="logo" href="/.">Joker's Blog</a><p class="description">高金涛</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kafka ISR设计及水印与leader epoch副本同步机制深入剖析</h1><div class="post-meta">Sep 23, 2018<span> | </span><span class="category"><a href="/categories/消息中间件/">消息中间件</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#帽子理论（Gilbert-和-Lynch-）"><span class="toc-number">1.</span> <span class="toc-text">帽子理论（Gilbert 和 Lynch ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#partition本质就是为了日志备份（对外最小的存储单元）"><span class="toc-number">2.</span> <span class="toc-text">partition本质就是为了日志备份（对外最小的存储单元）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Partitioner-三分天下"><span class="toc-number">3.</span> <span class="toc-text">Partitioner 三分天下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leader副本竞选上岗（in-sync-replicas）"><span class="toc-number">4.</span> <span class="toc-text">Leader副本竞选上岗（in-sync replicas）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#水印HW与末端位移LEO-gt-Leader副本"><span class="toc-number">5.</span> <span class="toc-text">水印HW与末端位移LEO =&gt; Leader副本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ISR设计优化（replica-lag-max-messages废弃）"><span class="toc-number">6.</span> <span class="toc-text">ISR设计优化（replica.lag.max.messages废弃）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HW同步机制"><span class="toc-number">7.</span> <span class="toc-text">HW同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HW指向哪里？"><span class="toc-number">7.1.</span> <span class="toc-text">HW指向哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leader与follower的HW（两阶段请求定终身）"><span class="toc-number">7.2.</span> <span class="toc-text">Leader与follower的HW（两阶段请求定终身）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HW更新延迟带来的刀山火海"><span class="toc-number">7.3.</span> <span class="toc-text">HW更新延迟带来的刀山火海</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="帽子理论（Gilbert-和-Lynch-）"><a href="#帽子理论（Gilbert-和-Lynch-）" class="headerlink" title="帽子理论（Gilbert 和 Lynch ）"></a>帽子理论（Gilbert 和 Lynch ）</h2><ul>
<li><p>一致性</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">any</span> <span class="built_in">read</span> operation that <span class="keyword">begins</span> <span class="keyword">after</span> <span class="keyword">a</span> <span class="built_in">write</span> operation completes must </span><br><span class="line"><span class="literal">return</span> that <span class="built_in">value</span>, <span class="keyword">or</span> <span class="keyword">the</span> <span class="built_in">result</span> <span class="keyword">of</span> <span class="keyword">a</span> later <span class="built_in">write</span> operation</span><br><span class="line"></span><br><span class="line">通过某个节点的写操作结果对后面通过其它节点的读操作可见</span><br><span class="line"></span><br><span class="line">强一致性：</span><br><span class="line">如果更新数据后，并发访问情况下后续读操作可立即感知该更新，称为强一致性。</span><br><span class="line"></span><br><span class="line">弱一致性：</span><br><span class="line">如果允许之后部分或者全部感知不到该更新，称为弱一致性。</span><br><span class="line"></span><br><span class="line">最终一致性：</span><br><span class="line">若在之后的一段时间（通常该时间不固定）后，一定可以感知到该更新，称为最终一致性。</span><br></pre></td></tr></table></figure>
</li>
<li><p>可用性（Availability）</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">every request received by a non-failing node <span class="keyword">in</span> the<span class="built_in"> system </span>must result <span class="keyword">in</span> a response</span><br><span class="line"></span><br><span class="line">任何一个没有发生故障的节点必须在有限的时间内返回合理的结果。</span><br></pre></td></tr></table></figure>
</li>
<li><p>分区容忍性（Partition Tolerance）</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">the<span class="built_in"> network </span>will be allowed <span class="keyword">to</span> lose arbitrarily many messages sent <span class="keyword">from</span> one node <span class="keyword">to</span> another</span><br><span class="line"></span><br><span class="line">部分节点宕机或者无法与其它节点通信时，各分区间还可保持分布式系统的功能。</span><br></pre></td></tr></table></figure>
</li>
<li><p>悖论总结：</p>
<p>可用性限定在无论是否集群节点宕机，只要有活着的节点，就会立即返回请求结果。若要限制返回结果必须是最近一次写的结果，就比较悲剧，若允许分区容忍性 =&gt; 分布式系统分区之间就存在数据同步机制，那么就有可能因为分区心跳切断，导致数据不一致。</p>
</li>
</ul>
<h2 id="partition本质就是为了日志备份（对外最小的存储单元）"><a href="#partition本质就是为了日志备份（对外最小的存储单元）" class="headerlink" title="partition本质就是为了日志备份（对外最小的存储单元）"></a>partition本质就是为了日志备份（对外最小的存储单元）</h2><p>Kafka中topic的每个partition有一个预写式的日志文件，虽然partition可以继续细分为若干个segment文件，但是对于上层应用来说可以将partition看成最小的存储单元（一个有多个segment文件拼接的“巨型”文件），每个partition都由一些列有序的、不可变的消息组成，这些消息被连续的追加到partition中。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/22/1673bba0c1d92e2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>partition本质就是为了日志备份，利用多份日志文件的副本（replica）备份来共同提供冗余机制来保持系统的高可用性。</li>
<li>kafka会把副本均匀的分配到所有的Broker上。在其中所有的副本中，会挑选一个Leader副本来对外提供服务，其他的副本统称为follower副本，只能被动的向leader副本请求数据。</li>
</ul>
<h2 id="Partitioner-三分天下"><a href="#Partitioner-三分天下" class="headerlink" title="Partitioner 三分天下"></a>Partitioner 三分天下</h2><p>下图展示了3个Partition把一个Topic主题数据流分成三份，通过Partioner路由依次追加到分区的末尾中。如果partition规则设置的合理，所有消息可以均匀分布到不同的partition里，这样就实现了水平扩展。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/22/1673bca604b58210?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>config/server.properties可以设置num.partitions参数，实现主题数据分流。</p>
<h2 id="Leader副本竞选上岗（in-sync-replicas）"><a href="#Leader副本竞选上岗（in-sync-replicas）" class="headerlink" title="Leader副本竞选上岗（in-sync replicas）"></a>Leader副本竞选上岗（in-sync replicas）</h2><ul>
<li>每一个分区都存在一个in-sync replicas。</li>
<li>in-sync replicas集合中的每一个副本都与leader保持同步状态，不在里面的保持不了同步状态。</li>
<li>只有ISR中的副本才有资格被选为leader。</li>
<li>Producer写入的消息只有被ISR中的副本都接收到，才被视为”已提交”。</li>
</ul>
<h2 id="水印HW与末端位移LEO-gt-Leader副本"><a href="#水印HW与末端位移LEO-gt-Leader副本" class="headerlink" title="水印HW与末端位移LEO =&gt; Leader副本"></a>水印HW与末端位移LEO =&gt; Leader副本</h2><ul>
<li>这里着重强调一下，Leader副本水印HW才真正决定了对外可看到的消息数量。</li>
<li>所有的副本都有LEO和HW。</li>
<li>Leader副本水印HW的更新发生在所有的副本都更新了最新的LEO后，Leader副本最终才认为可以更新Leader副本水印。</li>
</ul>
<h2 id="ISR设计优化（replica-lag-max-messages废弃）"><a href="#ISR设计优化（replica-lag-max-messages废弃）" class="headerlink" title="ISR设计优化（replica.lag.max.messages废弃）"></a>ISR设计优化（replica.lag.max.messages废弃）</h2><ul>
<li>解决了producer突然发起一大波消息，从而产生瞬时高峰流量。若设置replica.lag.max.messages=4，则follower副本会被瞬时的拉开距离，从而导致follower副本瞬间被踢出ISR。不过一段时间follower副本同步后，会再次进入ISR。</li>
<li>同步不同步，同步不同步反复出现，是多大的性能浪费。</li>
<li>0.9.0.0开始采用 replica. lag. time. max. ms，默认是10s，可谓是明智之举。</li>
</ul>
<h2 id="HW同步机制"><a href="#HW同步机制" class="headerlink" title="HW同步机制"></a>HW同步机制</h2><h3 id="HW指向哪里？"><a href="#HW指向哪里？" class="headerlink" title="HW指向哪里？"></a>HW指向哪里？</h3><ul>
<li>这里重点强调，都是无论HW还是LEO都是指向下一条消息</li>
<li>举例如下：如果一个普通topic的某个分区副本的LEO是10，那么该副本当前保存了10条消息，位移值范围是[0, 9]。此时若有一个producer向该副本插入一条消息，则该条消息的位移值是10，而副本LEO值则更新成11。</li>
</ul>
<h3 id="Leader与follower的HW（两阶段请求定终身）"><a href="#Leader与follower的HW（两阶段请求定终身）" class="headerlink" title="Leader与follower的HW（两阶段请求定终身）"></a>Leader与follower的HW（两阶段请求定终身）</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673c6b093d51af0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>follower 副本会不断地向leader副本发送Fetch请求</li>
</ul>
<p><strong>（1）follower 副本对象何时更新LEO？</strong></p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">follower 副本专属线程不断地向<span class="built_in">leader</span>副本所在broker发送FETCH请求。</span><br><span class="line"></span><br><span class="line"><span class="built_in">leader</span> 副本发送 FETCH response 给follower副本。</span><br><span class="line"></span><br><span class="line">Follower 拿到response之后取出位移数据写入到本地底层日志中，在该过程中其LEO值会被更新。</span><br></pre></td></tr></table></figure>

<p><strong>（2）leader 端非自己副本对象何时更新LEO？</strong></p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">leader</span> 端非自己副本对象 LEO值是在<span class="built_in">leader</span>端broker处理FETCH请求过程中被更新的。</span><br></pre></td></tr></table></figure>

<p><strong>（3） follower 副本对象何时更新HW？</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Follower</span> 副本对象更新HW是在其更新本地LEO之后。</span><br><span class="line"></span><br><span class="line">一旦follower向本地日志写完数据后它就会尝试更新其HW值。</span><br><span class="line">算法为取本地LEO与FETCH response中HW值的较小值</span><br></pre></td></tr></table></figure>

<p><strong>（4）leader 副本对象何时更新HW？</strong></p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Leader</span> 副本对象处理 Follower FETCH请求时在更新完<span class="built_in">leader</span> 端非自己副本对象的LEO后将尝试更新其自己HW值</span><br><span class="line"></span><br><span class="line">producer 端写入消息会更新<span class="built_in">leader</span> Replica的LEO</span><br><span class="line"></span><br><span class="line">副本被踢出ISR时</span><br><span class="line"></span><br><span class="line">某分区变更为<span class="built_in">leader</span>副本后</span><br></pre></td></tr></table></figure>

<p><strong>（5）两阶段请求定终身：</strong></p>
<p>第一次fetch请求仅获得了当前的数据，fetchOffset &lt; Leader LEO, 因为leader 端的非自己的副本leo 是根据fetch请求确定的，因此，只有第二次请求时，fetchOffset才会和Leader LEO相等，进而更新 leader HW ，进而响应为 leader HW，进而更新 Folloer HW。</p>
<h3 id="HW更新延迟带来的刀山火海"><a href="#HW更新延迟带来的刀山火海" class="headerlink" title="HW更新延迟带来的刀山火海"></a>HW更新延迟带来的刀山火海</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673c679cfaadb97?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>因为 fetchOffset是实实在在的需要位移。所以只有第二轮请求时，Follower才会在其现有位移的基础上，加1进行请求，从而连锁更新 会更新Leader非自己remoteLEO 和  Leader HW 和 Follower HW。</li>
<li>刀山火海就在一轮请求和第二轮请求之间发生了。</li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>gaojintao999@163.com</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/09/23/kafka ISR设计及水印与leader epoch副本同步机制深入剖析/">https://gjtmaster.github.io/2018/09/23/kafka ISR设计及水印与leader epoch副本同步机制深入剖析/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>The author owns the copyright, please indicate the source reproduced.</li></ul></div><br><div class="tags"><a href="/tags/Kafka/">Kafka</a><a href="/tags/消息中间件/">消息中间件</a></div><div class="post-nav"><a class="pre" href="/2018/09/25/Kafka 事务性之幂等性实现/">Kafka 事务性之幂等性实现</a><a class="next" href="/2018/09/21/kafka集群Controller竞选与责任设计思路架构详解/">kafka集群Controller竞选与责任设计思路架构详解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实时计算框架/">实时计算框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储格式/">数据存储格式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据的导入导出/">数据的导入导出</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志框架/">日志框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息中间件/">消息中间件</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/Flink/" style="font-size: 15px;">Flink</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/实时计算/" style="font-size: 15px;">实时计算</a> <a href="/tags/Flink-on-Yarn/" style="font-size: 15px;">Flink on Yarn</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/消息中间件/" style="font-size: 15px;">消息中间件</a> <a href="/tags/FlinkSQL/" style="font-size: 15px;">FlinkSQL</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/内存回收/" style="font-size: 15px;">内存回收</a> <a href="/tags/Logback/" style="font-size: 15px;">Logback</a> <a href="/tags/Json/" style="font-size: 15px;">Json</a> <a href="/tags/ogg/" style="font-size: 15px;">ogg</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/Flink 进阶：Time 深度解析/">Flink 进阶：Time 深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/Flink 进阶：Flink Connector详解/">Flink 进阶：Flink Connector详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/16/Flink 进阶：增量 Checkpoint 详解/">Flink 进阶：增量 Checkpoint 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/15/Flink 进阶：Runtime 核心机制剖析/">Flink 进阶：Runtime 核心机制剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/FlinkSQL深度解析/">Flink SQL 深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/16/Flink on Yarn HA/">Flink On Yarn HA</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink使用Logback作为日志框架的相关配置/">Flink使用Logback作为日志框架的相关配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink On Yan集群部署/">Flink On Yarn集群部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/Flink1.7.1与Kafka0.11.0.1/">Flink1.7.1与Kafka0.11.0.1</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/消息中间件高级技术要点企业级架构深入分析/">消息中间件高级技术要点企业级架构深入分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://matt33.com/" title="Matt's Blog" target="_blank">Matt's Blog</a><ul></ul><a href="https://www.haomwei.com/technology/maupassant-hexo.html" title="Maupassant's usage" target="_blank">Maupassant's usage</a><ul></ul><a href="https://www.jianshu.com/p/f4332764e8bd" title="hexo's usage" target="_blank">hexo's usage</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Joker's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>